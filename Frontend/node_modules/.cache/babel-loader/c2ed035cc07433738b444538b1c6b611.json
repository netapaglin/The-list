{"ast":null,"code":"// Products State - products data needed in the application level:\nexport class TaskState {\n  constructor() {\n    this.tasks = [];\n  }\n}\n\n// Products Action Type - any action which can be done on the above products state:\nexport let TasksActionType;\n\n// Products Action - any single object sent to the store during \"dispatch\":\n(function (TasksActionType) {\n  TasksActionType[\"FetchTasks\"] = \"FetchTasks\";\n  TasksActionType[\"AddTasks\"] = \"AddTasks\";\n  TasksActionType[\"UpdateTasks\"] = \"UpdateTasks\";\n  TasksActionType[\"DeleteTask\"] = \"DeleteTask\";\n})(TasksActionType || (TasksActionType = {}));\n// Products Action Creators - function for creating ProductsAction objects. each function creates one Action object:\nexport function fetchTaskAction(tasks) {\n  return {\n    type: TasksActionType.FetchTasks,\n    payload: tasks\n  };\n}\nexport function addTaskAction(tasks) {\n  return {\n    type: TasksActionType.AddTasks,\n    payload: tasks\n  };\n}\nexport function updateTaskAction(tasks) {\n  return {\n    type: TasksActionType.UpdateTasks,\n    payload: tasks\n  };\n}\nexport function deleteTaskAction(id) {\n  return {\n    type: TasksActionType.DeleteTask,\n    payload: id\n  };\n}\n\n// Products Reducer - the main function performing any action on products state:\n// the new ProductsState() is a default value for the first time only\nexport function tasksReducer() {\n  let currentState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new TaskState();\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  // Must duplicate the current state and not touch the given current state: \n  const newState = {\n    ...currentState\n  };\n  switch (action.type) {\n    case TasksActionType.FetchTasks:\n      newState.tasks = action.payload; // Here the payload is the products list.\n      break;\n    case TasksActionType.AddTasks:\n      newState.tasks.push(action.payload); // Here the payload is a single object to add.\n      break;\n    case TasksActionType.UpdateTasks:\n      const indexToUpdate = newState.tasks.findIndex(p => p._id === action.payload.id); // Here the payload is a single object to update.\n      if (indexToUpdate >= 0) {\n        newState.tasks[indexToUpdate] = action.payload;\n      }\n      break;\n    case TasksActionType.DeleteTask:\n      const indexToDelete = newState.tasks.findIndex(p => p._id === action.payload); // Here the payload is the id to delete.\n      if (indexToDelete >= 0) {\n        let newTasks = [...newState.tasks];\n        newTasks.splice(indexToDelete, 1);\n        newState.tasks = newTasks;\n      }\n      break;\n  }\n  return newState;\n}","map":{"version":3,"names":["TaskState","tasks","TasksActionType","fetchTaskAction","type","FetchTasks","payload","addTaskAction","AddTasks","updateTaskAction","UpdateTasks","deleteTaskAction","id","DeleteTask","tasksReducer","currentState","action","newState","push","indexToUpdate","findIndex","p","_id","indexToDelete","newTasks","splice"],"sources":["C:/Users/Neta/Documents/full stack/The list/Frontend/src/Redux/TaskState.ts"],"sourcesContent":["\r\n\r\nimport TaskModel from \"../Models/TaskModel\";\r\n\r\n// Products State - products data needed in the application level:\r\nexport class TaskState {\r\n    public tasks: TaskModel[] = [];\r\n}\r\n\r\n// Products Action Type - any action which can be done on the above products state:\r\nexport enum TasksActionType {\r\n    FetchTasks = \"FetchTasks\",\r\n    AddTasks = \"AddTasks\",\r\n    UpdateTasks = \"UpdateTasks\",\r\n    DeleteTask = \"DeleteTask\"\r\n}\r\n\r\n// Products Action - any single object sent to the store during \"dispatch\":\r\nexport interface TasksAction {\r\n    type: TasksActionType;\r\n    payload: any;\r\n}\r\n\r\n// Products Action Creators - function for creating ProductsAction objects. each function creates one Action object:\r\nexport function fetchTaskAction(tasks: TaskModel[]): TasksAction {\r\n    return { type: TasksActionType.FetchTasks, payload: tasks };\r\n}\r\nexport function addTaskAction(tasks: TaskModel): TasksAction {\r\n    return { type: TasksActionType.AddTasks, payload: tasks };\r\n}\r\nexport function updateTaskAction(tasks: TaskModel): TasksAction {\r\n    return { type: TasksActionType.UpdateTasks, payload: tasks };\r\n}\r\nexport function deleteTaskAction(id: string): TasksAction {\r\n    return { type: TasksActionType.DeleteTask, payload: id };\r\n}\r\n\r\n// Products Reducer - the main function performing any action on products state:\r\n// the new ProductsState() is a default value for the first time only\r\nexport function tasksReducer(currentState = new TaskState(), action: TasksAction): TaskState {\r\n\r\n    // Must duplicate the current state and not touch the given current state: \r\n    const newState = { ...currentState };\r\n\r\n    switch (action.type) {\r\n\r\n        case TasksActionType.FetchTasks:\r\n            newState.tasks = action.payload; // Here the payload is the products list.\r\n            break;\r\n\r\n        case TasksActionType.AddTasks:\r\n            newState.tasks.push(action.payload); // Here the payload is a single object to add.\r\n            break;\r\n\r\n        case TasksActionType.UpdateTasks:\r\n            const indexToUpdate = newState.tasks.findIndex(p => p._id === action.payload.id); // Here the payload is a single object to update.\r\n            if (indexToUpdate >= 0) {\r\n                newState.tasks[indexToUpdate] = action.payload;\r\n            }\r\n            break;\r\n\r\n        case TasksActionType.DeleteTask:\r\n            const indexToDelete = newState.tasks.findIndex(p => p._id === action.payload); // Here the payload is the id to delete.\r\n            if (indexToDelete >= 0) {\r\n                let newTasks = [...newState.tasks]\r\n                newTasks.splice(indexToDelete, 1);\r\n                newState.tasks = newTasks\r\n            }\r\n            break;\r\n    }\r\n\r\n    return newState;\r\n}\r\n"],"mappings":"AAIA;AACA,OAAO,MAAMA,SAAS,CAAC;EAAA;IAAA,KACZC,KAAK,GAAgB,EAAE;EAAA;AAClC;;AAEA;AACA,WAAYC,eAAe;;AAO3B;AAAA,WAPYA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe;AAa3B;AACA,OAAO,SAASC,eAAe,CAACF,KAAkB,EAAe;EAC7D,OAAO;IAAEG,IAAI,EAAEF,eAAe,CAACG,UAAU;IAAEC,OAAO,EAAEL;EAAM,CAAC;AAC/D;AACA,OAAO,SAASM,aAAa,CAACN,KAAgB,EAAe;EACzD,OAAO;IAAEG,IAAI,EAAEF,eAAe,CAACM,QAAQ;IAAEF,OAAO,EAAEL;EAAM,CAAC;AAC7D;AACA,OAAO,SAASQ,gBAAgB,CAACR,KAAgB,EAAe;EAC5D,OAAO;IAAEG,IAAI,EAAEF,eAAe,CAACQ,WAAW;IAAEJ,OAAO,EAAEL;EAAM,CAAC;AAChE;AACA,OAAO,SAASU,gBAAgB,CAACC,EAAU,EAAe;EACtD,OAAO;IAAER,IAAI,EAAEF,eAAe,CAACW,UAAU;IAAEP,OAAO,EAAEM;EAAG,CAAC;AAC5D;;AAEA;AACA;AACA,OAAO,SAASE,YAAY,GAAiE;EAAA,IAAhEC,YAAY,uEAAG,IAAIf,SAAS,EAAE;EAAA,IAAEgB,MAAmB;EAE5E;EACA,MAAMC,QAAQ,GAAG;IAAE,GAAGF;EAAa,CAAC;EAEpC,QAAQC,MAAM,CAACZ,IAAI;IAEf,KAAKF,eAAe,CAACG,UAAU;MAC3BY,QAAQ,CAAChB,KAAK,GAAGe,MAAM,CAACV,OAAO,CAAC,CAAC;MACjC;IAEJ,KAAKJ,eAAe,CAACM,QAAQ;MACzBS,QAAQ,CAAChB,KAAK,CAACiB,IAAI,CAACF,MAAM,CAACV,OAAO,CAAC,CAAC,CAAC;MACrC;IAEJ,KAAKJ,eAAe,CAACQ,WAAW;MAC5B,MAAMS,aAAa,GAAGF,QAAQ,CAAChB,KAAK,CAACmB,SAAS,CAACC,CAAC,IAAIA,CAAC,CAACC,GAAG,KAAKN,MAAM,CAACV,OAAO,CAACM,EAAE,CAAC,CAAC,CAAC;MAClF,IAAIO,aAAa,IAAI,CAAC,EAAE;QACpBF,QAAQ,CAAChB,KAAK,CAACkB,aAAa,CAAC,GAAGH,MAAM,CAACV,OAAO;MAClD;MACA;IAEJ,KAAKJ,eAAe,CAACW,UAAU;MAC3B,MAAMU,aAAa,GAAGN,QAAQ,CAAChB,KAAK,CAACmB,SAAS,CAACC,CAAC,IAAIA,CAAC,CAACC,GAAG,KAAKN,MAAM,CAACV,OAAO,CAAC,CAAC,CAAC;MAC/E,IAAIiB,aAAa,IAAI,CAAC,EAAE;QACpB,IAAIC,QAAQ,GAAG,CAAC,GAAGP,QAAQ,CAAChB,KAAK,CAAC;QAClCuB,QAAQ,CAACC,MAAM,CAACF,aAAa,EAAE,CAAC,CAAC;QACjCN,QAAQ,CAAChB,KAAK,GAAGuB,QAAQ;MAC7B;MACA;EAAM;EAGd,OAAOP,QAAQ;AACnB"},"metadata":{},"sourceType":"module"}